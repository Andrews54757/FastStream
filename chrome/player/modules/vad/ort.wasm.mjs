/* eslint-disable */
/* !
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Fe=Object.defineProperty;var Er=Object.getOwnPropertyDescriptor;var Sr=Object.getOwnPropertyNames;var Tr=Object.prototype.hasOwnProperty;var Ne=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var w=(t,e)=>()=>(t&&(e=t(t=0)),e);var We=(t,e)=>{for(var r in e)Fe(t,r,{get:e[r],enumerable:!0})},Ar=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Sr(e))!Tr.call(t,n)&&n!==r&&Fe(t,n,{get:()=>e[n],enumerable:!(o=Er(e,n))||o.enumerable});return t};var at=t=>Ar(Fe({},"__esModule",{value:!0}),t);var me,N,ne,Or,he,ye=w(()=>{"use strict";me=new Map,N=[],ne=(t,e,r)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=me.get(t);if(o===void 0)me.set(t,{backend:e,priority:r});else{if(o.priority>r)return;if(o.priority===r&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${r}`)}if(r>=0){let n=N.indexOf(t);n!==-1&&N.splice(n,1);for(let i=0;i<N.length;i++)if(me.get(N[i]).priority<=r){N.splice(i,0,t);return}N.push(t)}return}throw new TypeError("not a valid backend")},Or=async t=>{let e=me.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let r=!!e.initPromise;try{return r||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return r||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},he=async t=>{let e=t.executionProviders||[],r=e.map(a=>typeof a=="string"?a:a.name),o=r.length===0?N:r,n,i=[],s=new Set;for(let a of o){let u=await Or(a);typeof u=="string"?i.push({name:a,err:u}):(n||(n=u),n===u&&s.add(a))}if(!n)throw new Error(`no available backend found. ERR: ${i.map(a=>`[${a.name}] ${a.err}`).join(", ")}`);for(let{name:a,err:u}of i)r.includes(a)&&console.warn(`removing requested execution provider "${a}" from session options because it is not available: ${u}`);let f=e.filter(a=>s.has(typeof a=="string"?a:a.name));return[n,new Proxy(t,{get:(a,u)=>u==="executionProviders"?f:Reflect.get(a,u)})]}});var ut=w(()=>{"use strict";ye()});var ft,ct=w(()=>{"use strict";ft="1.20.0"});var dt,U,$e=w(()=>{"use strict";ct();dt="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:ft},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);dt=t}},get logLevel(){return dt}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var S,lt=w(()=>{"use strict";$e();S=U});var pt,mt,ht=w(()=>{"use strict";pt=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=t.dims[3],r.height=t.dims[2];let o=r.getContext("2d");if(o!=null){let n,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],i=t.dims[3]):(n=t.dims[3],i=t.dims[2]);let s=e?.format!==void 0?e.format:"RGB",f=e?.norm,a,u;f===void 0||f.mean===void 0?a=[255,255,255,255]:typeof f.mean=="number"?a=[f.mean,f.mean,f.mean,f.mean]:(a=[f.mean[0],f.mean[1],f.mean[2],0],f.mean[3]!==void 0&&(a[3]=f.mean[3])),f===void 0||f.bias===void 0?u=[0,0,0,0]:typeof f.bias=="number"?u=[f.bias,f.bias,f.bias,f.bias]:(u=[f.bias[0],f.bias[1],f.bias[2],0],f.bias[3]!==void 0&&(u[3]=f.bias[3]));let l=i*n,d=0,c=l,p=l*2,m=-1;s==="RGBA"?(d=0,c=l,p=l*2,m=l*3):s==="RGB"?(d=0,c=l,p=l*2):s==="RBG"&&(d=0,p=l,c=l*2);for(let h=0;h<i;h++)for(let E=0;E<n;E++){let O=(t.data[d++]-u[0])*a[0],y=(t.data[c++]-u[1])*a[1],g=(t.data[p++]-u[2])*a[2],A=m===-1?255:(t.data[m++]-u[3])*a[3];o.fillStyle="rgba("+O+","+y+","+g+","+A+")",o.fillRect(E,h,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},mt=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(r!=null){let n,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],i=t.dims[1],s=t.dims[3]):(n=t.dims[3],i=t.dims[2],s=t.dims[1]);let f=e!==void 0&&e.format!==void 0?e.format:"RGB",a=e?.norm,u,l;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],255],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?l=[0,0,0,0]:typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:(l=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(l[3]=a.bias[3]));let d=i*n;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let c=4,p=0,m=1,h=2,E=3,O=0,y=d,g=d*2,A=-1;f==="RGBA"?(O=0,y=d,g=d*2,A=d*3):f==="RGB"?(O=0,y=d,g=d*2):f==="RBG"&&(O=0,g=d,y=d*2),o=r.createImageData(n,i);for(let B=0;B<i*n;p+=c,m+=c,h+=c,E+=c,B++)o.data[p]=(t.data[O++]-l[0])*u[0],o.data[m]=(t.data[y++]-l[1])*u[1],o.data[h]=(t.data[g++]-l[2])*u[2],o.data[E]=A===-1?255:(t.data[A++]-l[3])*u[3]}else throw new Error("Can not access image data");return o}});var Ge,yt,wt,gt,bt,Et=w(()=>{"use strict";we();Ge=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:o}=e,n=e.norm??{mean:255,bias:0},i,s;typeof n.mean=="number"?i=[n.mean,n.mean,n.mean,n.mean]:i=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?s=[n.bias,n.bias,n.bias,n.bias]:s=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let f=e.format!==void 0?e.format:"RGBA",a=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",u=r*o,l=a==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),d=4,c=0,p=1,m=2,h=3,E=0,O=u,y=u*2,g=-1;f==="RGB"&&(d=3,c=0,p=1,m=2,h=-1),a==="RGBA"?g=u*3:a==="RBG"?(E=0,y=u,O=u*2):a==="BGR"&&(y=0,O=u,E=u*2);for(let B=0;B<u;B++,c+=d,m+=d,p+=d,h+=d)l[E++]=(t[c]+s[0])/i[0],l[O++]=(t[p]+s[1])/i[1],l[y++]=(t[m]+s[2])/i[2],g!==-1&&h!==-1&&(l[g++]=(t[h]+s[3])/i[3]);return a==="RGBA"?new P("float32",l,[1,4,r,o]):new P("float32",l,[1,3,r,o])},yt=async(t,e)=>{let r=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,n=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,i=typeof t=="string",s,f=e??{},a=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=l=>l instanceof HTMLCanvasElement||l instanceof OffscreenCanvas?l.getContext("2d"):null;if(r){let l=a();l.width=t.width,l.height=t.height;let d=u(l);if(d!=null){let c=t.height,p=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(c=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(f=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");f.tensorFormat="RGBA",f.height=c,f.width=p}else f.tensorFormat="RGBA",f.height=c,f.width=p;d.drawImage(t,0,0),s=d.getImageData(0,0,p,c).data}else throw new Error("Can not access image data")}else if(o){let l,d;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(l=e.resizedHeight,d=e.resizedWidth):(l=t.height,d=t.width),e!==void 0&&(f=e),f.format="RGBA",f.height=l,f.width=d,e!==void 0){let c=a();c.width=d,c.height=l;let p=u(c);if(p!=null)p.putImageData(t,0,0),s=p.getImageData(0,0,d,l).data;else throw new Error("Can not access image data")}else s=t.data}else if(n){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let l=a();l.width=t.width,l.height=t.height;let d=u(l);if(d!=null){let c=t.height,p=t.width;return d.drawImage(t,0,0,p,c),s=d.getImageData(0,0,p,c).data,f.height=c,f.width=p,Ge(s,f)}else throw new Error("Can not access image data")}else{if(i)return new Promise((l,d)=>{let c=a(),p=u(c);if(!t||!p)return d();let m=new Image;m.crossOrigin="Anonymous",m.src=t,m.onload=()=>{c.width=m.width,c.height=m.height,p.drawImage(m,0,0,c.width,c.height);let h=p.getImageData(0,0,c.width,c.height);f.height=c.height,f.width=c.width,l(Ge(h.data,f))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Ge(s,f);throw new Error("Input data provided is not supported - aborted tensor creation")},wt=(t,e)=>{let{width:r,height:o,download:n,dispose:i}=e,s=[1,o,r,4];return new P({location:"texture",type:"float32",texture:t,dims:s,download:n,dispose:i})},gt=(t,e)=>{let{dataType:r,dims:o,download:n,dispose:i}=e;return new P({location:"gpu-buffer",type:r??"float32",gpuBuffer:t,dims:o,download:n,dispose:i})},bt=(t,e,r)=>new P({location:"cpu-pinned",type:t,data:e,dims:r??[e.length]})});var W,oe,St,Tt,At=w(()=>{"use strict";W=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),oe=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),St=!1,Tt=()=>{if(!St){St=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,r=typeof Float16Array<"u"&&Float16Array.from;t&&(W.set("int64",BigInt64Array),oe.set(BigInt64Array,"int64")),e&&(W.set("uint64",BigUint64Array),oe.set(BigUint64Array,"uint64")),r?(W.set("float16",Float16Array),oe.set(Float16Array,"float16")):W.set("float16",Uint16Array)}}});var Ot,vt,xt=w(()=>{"use strict";we();Ot=t=>{let e=1;for(let r=0;r<t.length;r++){let o=t[r];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);e*=o}return e},vt=(t,e)=>{switch(t.location){case"cpu":return new P(t.type,t.data,e);case"cpu-pinned":return new P({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new P({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new P({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var P,we=w(()=>{"use strict";ht();Et();At();xt();P=class{constructor(e,r,o){Tt();let n,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,n=e.type,i=e.dims,e.location){case"cpu-pinned":{let f=W.get(n);if(!f)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof f))throw new TypeError(`buffer should be of type ${f.name}`);this.cpuData=e.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let f,a;if(typeof e=="string")if(n=e,a=o,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");f=r}else{let u=W.get(e);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&u===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${u.name} as data.`);e==="uint64"||e==="int64"?f=u.from(r,BigInt):f=u.from(r)}else if(r instanceof u)f=r;else throw new TypeError(`A ${n} tensor's data must be type of ${u}`)}else if(a=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let u=typeof e[0];if(u==="string")n="string",f=e;else if(u==="boolean")n="bool",f=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else{let u=oe.get(e.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=u,f=e}if(a===void 0)a=[f.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");i=a,this.cpuData=f,this.dataLocation="cpu"}let s=Ot(i);if(this.cpuData&&s!==this.cpuData.length&&!((n==="uint4"||n==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=i,this.size=s}static async fromImage(e,r){return yt(e,r)}static fromTexture(e,r){return wt(e,r)}static fromGpuBuffer(e,r){return gt(e,r)}static fromPinnedBuffer(e,r,o){return bt(e,r,o)}toDataURL(e){return pt(this,e)}toImageData(e){return mt(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return vt(this,e)}}});var I,ge=w(()=>{"use strict";we();I=P});var It,Pt,$,G,ze=w(()=>{"use strict";$e();It=(t,e)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${t}::ORT::${e}`)},Pt=(t,e)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let n=0;n<r.length;n++){if(o&&!r[n].includes("TRACE_FUNC")){let i=`FUNC_${t}::${r[n].trim().split(" ")[1]}`;e&&(i+=`::${e}`),It("CPU",i);return}r[n].includes("TRACE_FUNC")&&(o=!0)}},$=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Pt("BEGIN",t)},G=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Pt("END",t)}});var be,Bt=w(()=>{"use strict";ye();ge();ze();be=class t{constructor(e){this.handler=e}async run(e,r,o){$();let n={},i={};if(typeof e!="object"||e===null||e instanceof I||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let u of r){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);n[u]=null}if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,l=Object.getOwnPropertyNames(r);for(let d of this.outputNames)if(l.indexOf(d)!==-1){let c=r[d];(c===null||c instanceof I)&&(u=!0,s=!1,n[d]=c)}if(u){if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else i=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof e[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(s)for(let u of this.outputNames)n[u]=null;let f=await this.handler.run(e,n,i),a={};for(let u in f)if(Object.hasOwnProperty.call(f,u)){let l=f[u];l instanceof I?a[u]=l:a[u]=new I(l.type,l.data,l.dims)}return G(),a}async release(){return this.handler.dispose()}static async create(e,r,o,n){$();let i,s={};if(typeof e=="string"){if(i=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let l=e,d=0,c=e.byteLength;if(typeof r=="object"&&r!==null)s=r;else if(typeof r=="number"){if(d=r,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=l.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${l.byteLength}).`);if(c=e.byteLength-d,typeof o=="number"){if(c=o,!Number.isSafeInteger(c))throw new RangeError("'byteLength' must be an integer.");if(c<=0||d+c>l.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${l.byteLength-d}].`);if(typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(l,d,c)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[f,a]=await he(s),u=await f.createInferenceSessionHandler(i,a);return G(),new t(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var vr,Lt=w(()=>{"use strict";Bt();vr=be});var Ct=w(()=>{"use strict"});var Ut=w(()=>{"use strict"});var Mt=w(()=>{"use strict"});var Dt=w(()=>{"use strict"});var xr,Ee,Rt=w(()=>{"use strict";ye();ge();xr="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Ee=class t{constructor(e,r,o){this.handler=e,this.hasOptimizerModel=r,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,r){let o=e.evalModel||"",n=e.optimizerModel||"",i=r||{},[s,f]=await he(i);if(s.createTrainingSessionHandler){let a=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,o,n,f);return new t(a,!!e.optimizerModel,!!e.evalModel)}else throw new Error(xr)}typeNarrowingForRunStep(e,r,o,n,i){let s={},f={};if(typeof o!="object"||o===null||o instanceof I||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(r.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);s[u]=null}if(typeof i=="object"&&i!==null)f=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,l=Object.getOwnPropertyNames(n);for(let d of r)if(l.indexOf(d)!==-1){let c=n[d];(c===null||c instanceof I)&&(u=!0,a=!1,s[d]=c)}if(u){if(typeof i=="object"&&i!==null)f=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else f=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of e)if(typeof o[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(a)for(let u of r)s[u]=null;return[s,f]}convertHandlerReturnTypeToMapOfTensors(e){let r={};for(let o in e)if(Object.hasOwnProperty.call(e,o)){let n=e[o];n instanceof I?r[o]=n:r[o]=new I(n.type,n.data,n.dims)}return r}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,r,o){let[n,i]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,r,o),s=await this.handler.runTrainStep(e,n,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,r,o){if(this.hasEvalModel){let[n,i]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,r,o),s=await this.handler.runEvalStep(e,n,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,r=!0){let o=await this.getParametersSize(r);if(e.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,r)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var Ir,_t=w(()=>{"use strict";Rt();Ir=Ee});var He={};We(He,{InferenceSession:()=>vr,TRACE:()=>It,TRACE_FUNC_BEGIN:()=>$,TRACE_FUNC_END:()=>G,Tensor:()=>I,TrainingSession:()=>Ir,env:()=>S,registerBackend:()=>ne});var z=w(()=>{"use strict";ut();lt();Lt();ge();Ct();Ut();ze();Mt();Dt();_t()});var Se=w(()=>{"use strict"});var Wt={};We(Wt,{default:()=>Pr});var Ft,Nt,Pr,$t=w(()=>{"use strict";je();H();se();Ft="ort-wasm-proxy-worker",Nt=globalThis.self?.name===Ft;Nt&&(self.onmessage=t=>{let{type:e,in:r}=t.data;try{switch(e){case"init-wasm":Te(r.wasm).then(()=>{Ae(r).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;Oe(n,o).then(()=>{postMessage({type:e})},i=>{postMessage({type:e,err:i})});break}case"copy-from":{let{buffer:o}=r,n=ie(o);postMessage({type:e,out:n});break}case"create":{let{model:o,options:n}=r;ve(o,n).then(i=>{postMessage({type:e,out:i})},i=>{postMessage({type:e,err:i})});break}case"release":xe(r),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:n,inputs:i,outputIndices:s,options:f}=r;Ie(o,n,i,s,new Array(s.length).fill(null),f).then(a=>{a.some(u=>u[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:a},Be([...i,...a]))},a=>{postMessage({type:e,err:a})});break}case"end-profiling":Pe(r),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Pr=Nt?null:t=>new Worker(t??D,{type:"module",name:Ft})});var D,Br,zt,Lr,Cr,Ht,Ur,Gt,jt,Vt,se=w(()=>{"use strict";Se();D=!1?void 0:import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),Br=!1||typeof location>"u"?void 0:location.origin,zt=(t,e)=>{try{let r=e??D;return(r?new URL(t,r):new URL(t)).origin===Br}catch{return!1}},Lr=(t,e)=>{let r=e??D;try{return(r?new URL(t,r):new URL(t)).href}catch{return}},Cr=(t,e)=>`${e??"./"}${t}`,Ht=async t=>{let r=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},Ur=async t=>(await import(/*webpackIgnore:true*/t)).default,Gt=($t(),at(Wt)).default,jt=async()=>{if(!D)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(zt(D))return[void 0,Gt()];let t=await Ht(D);return[t,Gt(t)]},Vt=async(t,e,r)=>{{let o="ort-wasm-simd-threaded.mjs",n=t??Lr(o,e),i=!!1&&r&&n&&!zt(n,e),s=i?await Ht(n):n??Cr(o,e);return[i?s:void 0,await Ur(s)]}}});var Ve,Ye,Le,Yt,Mr,Dr,Te,v,H=w(()=>{"use strict";se();Ye=!1,Le=!1,Yt=!1,Mr=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Dr=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Te=async t=>{if(Ye)return Promise.resolve();if(Le)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Yt)throw new Error("previous call to 'initializeWebAssembly()' failed.");Le=!0;let e=t.initTimeout,r=t.numThreads;if(!Dr())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=Mr();r>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=r=1);let n=t.wasmPaths,i=typeof n=="string"?n:void 0,s=n?.mjs,f=s?.href??s,a=n?.wasm,u=a?.href??a,l=t.wasmBinary,[d,c]=await Vt(f,i,r>1),p=!1,m=[];if(e>0&&m.push(new Promise(h=>{setTimeout(()=>{p=!0,h()},e)})),m.push(new Promise((h,E)=>{let O={numThreads:r};l?O.wasmBinary=l:(u||i)&&(O.locateFile=(y,g)=>u??(i??g)+y),c(O).then(y=>{Le=!1,Ye=!0,Ve=y,h(),d&&URL.revokeObjectURL(d)},y=>{Le=!1,Yt=!0,E(y)})})),await Promise.race(m),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},v=()=>{if(Ye&&Ve)return Ve;throw new Error("WebAssembly is not initialized yet.")}});var x,ae,T,Ce=w(()=>{"use strict";H();x=(t,e)=>{let r=v(),o=r.lengthBytesUTF8(t)+1,n=r._malloc(o);return r.stringToUTF8(t,n,o),e.push(n),n},ae=(t,e,r,o)=>{if(typeof t=="object"&&t!==null){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach(([n,i])=>{let s=e?e+n:n;if(typeof i=="object")ae(i,s+".",r,o);else if(typeof i=="string"||typeof i=="number")o(s,i.toString());else if(typeof i=="boolean")o(s,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},T=t=>{let e=v(),r=e.stackSave();try{let o=e.stackAlloc(8);e._OrtGetLastError(o,o+4);let n=e.HEAP32[o/4],i=e.HEAPU32[o/4+1],s=i?e.UTF8ToString(i):"";throw new Error(`${t} ERROR_CODE: ${n}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(r)}}});var qt,Jt=w(()=>{"use strict";H();Ce();qt=t=>{let e=v(),r=0,o=[],n=t||{};try{if(t?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(n.terminate=!1);let i=0;return t?.tag!==void 0&&(i=x(t.tag,o)),r=e._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,i),r===0&&T("Can't create run options."),t?.extra!==void 0&&ae(t.extra,"",new WeakSet,(s,f)=>{let a=x(s,o),u=x(f,o);e._OrtAddRunConfigEntry(r,a,u)!==0&&T(`Can't set a run config entry: ${s} - ${f}.`)}),[r,o]}catch(i){throw r!==0&&e._OrtReleaseRunOptions(r),o.forEach(s=>e._free(s)),i}}});var Rr,_r,kr,Fr,Xt,Kt=w(()=>{"use strict";H();Ce();Rr=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},_r=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},kr=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(t.enableMemPattern=!1)},Fr=(t,e,r)=>{for(let o of e){let n=typeof o=="string"?o:o.name;switch(n){case"webnn":if(n="WEBNN",typeof o!="string"){let f=o?.deviceType;if(f){let a=x("deviceType",r),u=x(f,r);v()._OrtAddSessionConfigEntry(t,a,u)!==0&&T(`Can't set a session config entry: 'deviceType' - ${f}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let f=x("preferredLayout",r),a=x(s.preferredLayout,r);v()._OrtAddSessionConfigEntry(t,f,a)!==0&&T(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let i=x(n,r);v()._OrtAppendExecutionProvider(t,i)!==0&&T(`Can't append execution provider: ${n}.`)}},Xt=t=>{let e=v(),r=0,o=[],n=t||{};kr(n);try{let i=Rr(n.graphOptimizationLevel??"all"),s=_r(n.executionMode??"sequential"),f=typeof n.logId=="string"?x(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let u=n.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let l=typeof n.optimizedModelFilePath=="string"?x(n.optimizedModelFilePath,o):0;if(r=e._OrtCreateSessionOptions(i,!!n.enableCpuMemArena,!!n.enableMemPattern,s,!!n.enableProfiling,0,f,a,u,l),r===0&&T("Can't create session options."),n.executionProviders&&Fr(r,n.executionProviders,o),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);let d=x("enableGraphCapture",o),c=x(n.enableGraphCapture.toString(),o);e._OrtAddSessionConfigEntry(r,d,c)!==0&&T(`Can't set a session config entry: 'enableGraphCapture' - ${n.enableGraphCapture}.`)}if(n.freeDimensionOverrides)for(let[d,c]of Object.entries(n.freeDimensionOverrides)){if(typeof d!="string")throw new Error(`free dimension override name must be a string: ${d}`);if(typeof c!="number"||!Number.isInteger(c)||c<0)throw new Error(`free dimension override value must be a non-negative integer: ${c}`);let p=x(d,o);e._OrtAddFreeDimensionOverride(r,p,c)!==0&&T(`Can't set a free dimension override: ${d} - ${c}.`)}return n.extra!==void 0&&ae(n.extra,"",new WeakSet,(d,c)=>{let p=x(d,o),m=x(c,o);e._OrtAddSessionConfigEntry(r,p,m)!==0&&T(`Can't set a session config entry: ${d} - ${c}.`)}),[r,o]}catch(i){throw r!==0&&e._OrtReleaseSessionOptions(r),o.forEach(s=>e._free(s)),i}}});var qe,Qt,Je,Zt,er,Ue,tr,Xe=w(()=>{"use strict";qe=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},Qt=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},Je=(t,e)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],o=typeof e=="number"?e:e.reduce((n,i)=>n*i,1);return r>0?Math.ceil(o*r):void 0},Zt=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},er=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},Ue=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",tr=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}});var ue,Ke=w(()=>{"use strict";Se();ue=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=Ne("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:r}=Ne("node:fs"),o=r(t),n=[];for await(let i of o)n.push(i);return new Uint8Array(Buffer.concat(n))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let r=e.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let n=e.body.getReader(),i;try{i=new ArrayBuffer(o)}catch(f){if(f instanceof RangeError){let a=Math.ceil(o/65536);i=new WebAssembly.Memory({initial:a,maximum:a}).buffer}else throw f}let s=0;for(;;){let{done:f,value:a}=await n.read();if(f)break;let u=a.byteLength;new Uint8Array(i,s,u).set(a),s+=u}return new Uint8Array(i,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var Nr,Ae,Oe,q,Wr,ie,ve,xe,rr,Ie,Pe,Be,je=w(()=>{"use strict";Jt();Kt();Xe();H();Ce();Ke();Nr=(t,e)=>{v()._OrtInit(t,e)!==0&&T("Can't initialize onnxruntime.")},Ae=async t=>{Nr(t.wasm.numThreads,er(t.logLevel))},Oe=async(t,e)=>{},q=new Map,Wr=t=>{let e=v(),r=e.stackSave();try{let o=e.stackAlloc(8);return e._OrtGetInputOutputCount(t,o,o+4)!==0&&T("Can't get session input/output count."),[e.HEAP32[o/4],e.HEAP32[o/4+1]]}finally{e.stackRestore(r)}},ie=t=>{let e=v(),r=e._malloc(t.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,r),[r,t.byteLength]},ve=async(t,e)=>{let r,o,n=v();Array.isArray(t)?[r,o]=t:t.buffer===n.HEAPU8.buffer?[r,o]=[t.byteOffset,t.byteLength]:[r,o]=ie(t);let i=0,s=0,f=0,a=[],u=[],l=[];try{if([s,a]=Xt(e),e?.externalData&&n.mountExternalData){let y=[];for(let g of e.externalData){let A=typeof g=="string"?g:g.path;y.push(ue(typeof g=="string"?g:g.data).then(B=>{n.mountExternalData(A,B)}))}await Promise.all(y)}for(let y of e?.executionProviders??[])if((typeof y=="string"?y:y.name)==="webnn"){if(n.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof y!="string"){let A=y,B=A?.context,K=A?.gpuDevice,ce=A?.deviceType,Q=A?.numThreads,de=A?.powerPreference;B?n.currentContext=B:K?n.currentContext=await navigator.ml.createContext(K):n.currentContext=await navigator.ml.createContext({deviceType:ce,numThreads:Q,powerPreference:de})}else n.currentContext=await navigator.ml.createContext();break}i=await n._OrtCreateSession(r,o,s),i===0&&T("Can't create a session."),n.currentContext&&(n.currentContext=void 0);let[d,c]=Wr(i),p=!!e?.enableGraphCapture,m=[],h=[],E=[];for(let y=0;y<d;y++){let g=n._OrtGetInputName(i,y);g===0&&T("Can't get an input name."),u.push(g),m.push(n.UTF8ToString(g))}for(let y=0;y<c;y++){let g=n._OrtGetOutputName(i,y);g===0&&T("Can't get an output name."),l.push(g);let A=n.UTF8ToString(g);h.push(A)}let O=null;return q.set(i,[i,u,l,O,p,!1]),[i,m,h]}catch(d){throw u.forEach(c=>n._OrtFree(c)),l.forEach(c=>n._OrtFree(c)),f!==0&&n._OrtReleaseBinding(f),i!==0&&n._OrtReleaseSession(i),d}finally{n._free(r),s!==0&&n._OrtReleaseSessionOptions(s),a.forEach(d=>n._free(d)),n.unmountExternalData?.()}},xe=t=>{let e=v(),r=q.get(t);if(!r)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,n,i,s,f]=r;s&&(f&&e._OrtClearBoundOutputs(s.handle),e._OrtReleaseBinding(s.handle)),e.jsepOnReleaseSession?.(t),n.forEach(a=>e._OrtFree(a)),i.forEach(a=>e._OrtFree(a)),e._OrtReleaseSession(o),q.delete(t)},rr=(t,e,r,o,n,i=!1)=>{if(!t){e.push(0);return}let s=v(),f=t[0],a=t[1],u=t[3],l,d;if(f==="string"&&u==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(i&&u!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${n} when enableGraphCapture is true.`);if(u==="gpu-buffer"){let m=t[2].gpuBuffer;d=Je(qe(f),a);let h=s.jsepRegisterBuffer;if(!h)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');l=h(o,n,m,d)}else{let m=t[2];if(Array.isArray(m)){d=4*m.length,l=s._malloc(d),r.push(l);let h=l/4;for(let E=0;E<m.length;E++){if(typeof m[E]!="string")throw new TypeError(`tensor data at index ${E} is not a string`);s.HEAPU32[h++]=x(m[E],r)}}else d=m.byteLength,l=s._malloc(d),r.push(l),s.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,d),l)}let c=s.stackSave(),p=s.stackAlloc(4*a.length);try{let m=p/4;a.forEach(E=>s.HEAP32[m++]=E);let h=s._OrtCreateTensor(qe(f),l,d,p,a.length,tr(u));h===0&&T(`Can't create tensor for input/output. session=${o}, index=${n}.`),e.push(h)}finally{s.stackRestore(c)}},Ie=async(t,e,r,o,n,i)=>{let s=v(),f=q.get(t);if(!f)throw new Error(`cannot run inference. invalid session id: ${t}`);let a=f[0],u=f[1],l=f[2],d=f[3],c=f[4],p=f[5],m=e.length,h=o.length,E=0,O=[],y=[],g=[],A=[],B=s.stackSave(),K=s.stackAlloc(m*4),ce=s.stackAlloc(m*4),Q=s.stackAlloc(h*4),de=s.stackAlloc(h*4);try{[E,O]=qt(i);for(let b=0;b<m;b++)rr(r[b],y,A,t,e[b],c);for(let b=0;b<h;b++)rr(n[b],g,A,t,m+o[b],c);let _=K/4,hr=ce/4,yr=Q/4,wr=de/4;for(let b=0;b<m;b++)s.HEAPU32[_++]=y[b],s.HEAPU32[hr++]=u[e[b]];for(let b=0;b<h;b++)s.HEAPU32[yr++]=g[b],s.HEAPU32[wr++]=l[o[b]];s.jsepOnRunStart?.(a);let tt;tt=await s._OrtRun(a,ce,K,m,de,h,Q,E),tt!==0&&T("failed to call OrtRun().");let Z=[];for(let b=0;b<h;b++){let ee=s.HEAPU32[Q/4+b];if(ee===g[b]){Z.push(n[b]);continue}let rt=s.stackSave(),F=s.stackAlloc(4*4),le=!1,M,k=0;try{s._OrtGetTensorData(ee,F,F+4,F+8,F+12)!==0&&T(`Can't access output tensor data on index ${b}.`);let pe=F/4,nt=s.HEAPU32[pe++];k=s.HEAPU32[pe++];let ot=s.HEAPU32[pe++],gr=s.HEAPU32[pe++],te=[];for(let L=0;L<gr;L++)te.push(s.HEAPU32[ot/4+L]);s._OrtFree(ot);let re=te.reduce((L,C)=>L*C,1);M=Qt(nt);let st=d?.outputPreferredLocations[o[b]];if(M==="string"){if(st==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let L=[],C=k/4;for(let Y=0;Y<re;Y++){let it=s.HEAPU32[C++],br=Y===re-1?void 0:s.HEAPU32[C]-it;L.push(s.UTF8ToString(it,br))}Z.push([M,te,L,"cpu"])}else if(st==="gpu-buffer"&&re>0){let L=s.jsepGetBuffer;if(!L)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let C=L(k),Y=Je(nt,re);if(Y===void 0||!Ue(M))throw new Error(`Unsupported data type: ${M}`);le=!0,Z.push([M,te,{gpuBuffer:C,download:s.jsepCreateDownloader(C,Y,M),dispose:()=>{s._OrtReleaseTensor(ee)}},"gpu-buffer"])}else{let L=Zt(M),C=new L(re);new Uint8Array(C.buffer,C.byteOffset,C.byteLength).set(s.HEAPU8.subarray(k,k+C.byteLength)),Z.push([M,te,C,"cpu"])}}finally{s.stackRestore(rt),M==="string"&&k&&s._free(k),le||s._OrtReleaseTensor(ee)}}return d&&!c&&(s._OrtClearBoundOutputs(d.handle),q.set(t,[a,u,l,d,c,!1])),Z}finally{s.stackRestore(B),y.forEach(_=>s._OrtReleaseTensor(_)),g.forEach(_=>s._OrtReleaseTensor(_)),A.forEach(_=>s._free(_)),E!==0&&s._OrtReleaseRunOptions(E),O.forEach(_=>s._free(_))}},Pe=t=>{let e=v(),r=q.get(t);if(!r)throw new Error("invalid session id");let o=r[0],n=e._OrtEndProfiling(o);n===0&&T("Can't get an profile file name."),e._OrtFree(n)},Be=t=>{let e=[];for(let r of t){let o=r[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var V,R,fe,De,Re,Me,Qe,Ze,J,X,Gr,nr,or,sr,ir,ar,ur,fr,et=w(()=>{"use strict";z();je();H();se();V=()=>!!S.wasm.proxy&&typeof document<"u",fe=!1,De=!1,Re=!1,Ze=new Map,J=(t,e)=>{let r=Ze.get(t);r?r.push(e):Ze.set(t,[e])},X=()=>{if(fe||!De||Re||!R)throw new Error("worker not ready")},Gr=t=>{switch(t.data.type){case"init-wasm":fe=!1,t.data.err?(Re=!0,Qe[1](t.data.err)):(De=!0,Qe[0]()),Me&&(URL.revokeObjectURL(Me),Me=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=Ze.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},nr=async()=>{if(!De){if(fe)throw new Error("multiple calls to 'initWasm()' detected.");if(Re)throw new Error("previous call to 'initWasm()' failed.");if(fe=!0,V())return new Promise((t,e)=>{R?.terminate(),jt().then(([r,o])=>{try{R=o,R.onerror=i=>e(i),R.onmessage=Gr,Qe=[t,e];let n={type:"init-wasm",in:S};R.postMessage(n),Me=r}catch(n){e(n)}},e)});try{await Te(S.wasm),await Ae(S),De=!0}catch(t){throw Re=!0,t}finally{fe=!1}}},or=async t=>{if(V())return X(),new Promise((e,r)=>{J("init-ep",[e,r]);let o={type:"init-ep",in:{epName:t,env:S}};R.postMessage(o)});await Oe(S,t)},sr=async t=>V()?(X(),new Promise((e,r)=>{J("copy-from",[e,r]);let o={type:"copy-from",in:{buffer:t}};R.postMessage(o,[t.buffer])})):ie(t),ir=async(t,e)=>{if(V()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return X(),new Promise((r,o)=>{J("create",[r,o]);let n={type:"create",in:{model:t,options:{...e}}},i=[];t instanceof Uint8Array&&i.push(t.buffer),R.postMessage(n,i)})}else return ve(t,e)},ar=async t=>{if(V())return X(),new Promise((e,r)=>{J("release",[e,r]);let o={type:"release",in:t};R.postMessage(o)});xe(t)},ur=async(t,e,r,o,n,i)=>{if(V()){if(r.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return X(),new Promise((s,f)=>{J("run",[s,f]);let a=r,u={type:"run",in:{sessionId:t,inputIndices:e,inputs:a,outputIndices:o,options:i}};R.postMessage(u,Be(a))})}else return Ie(t,e,r,o,n,i)},fr=async t=>{if(V())return X(),new Promise((e,r)=>{J("end-profiling",[e,r]);let o={type:"end-profiling",in:t};R.postMessage(o)});Pe(t)}});var cr,zr,_e,dr=w(()=>{"use strict";z();et();Xe();Se();Ke();cr=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},zr=t=>{switch(t[3]){case"cpu":return new I(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!Ue(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:r,download:o,dispose:n}=t[2];return I.fromGpuBuffer(r,{dataType:e,dims:t[1],download:o,dispose:n})}default:throw new Error(`invalid data location: ${t[3]}`)}},_e=class{async fetchModelAndCopyToWasmMemory(e){return sr(await ue(e))}async loadModel(e,r){$();let o;typeof e=="string"?!1?o=await ue(e):o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames]=await ir(o,r),G()}async dispose(){return ar(this.sessionId)}async run(e,r,o){$();let n=[],i=[];Object.entries(e).forEach(c=>{let p=c[0],m=c[1],h=this.inputNames.indexOf(p);if(h===-1)throw new Error(`invalid input '${p}'`);n.push(m),i.push(h)});let s=[],f=[];Object.entries(r).forEach(c=>{let p=c[0],m=c[1],h=this.outputNames.indexOf(p);if(h===-1)throw new Error(`invalid output '${p}'`);s.push(m),f.push(h)});let a=n.map((c,p)=>cr(c,()=>`input "${this.inputNames[i[p]]}"`)),u=s.map((c,p)=>c?cr(c,()=>`output "${this.outputNames[f[p]]}"`):null),l=await ur(this.sessionId,i,a,f,u,o),d={};for(let c=0;c<l.length;c++)d[this.outputNames[f[c]]]=s[c]??zr(l[c]);return G(),d}startProfiling(){}endProfiling(){fr(this.sessionId)}}});var Hr,ke,lr=w(()=>{"use strict";z();et();dr();se();Hr=()=>{if((typeof S.wasm.initTimeout!="number"||S.wasm.initTimeout<0)&&(S.wasm.initTimeout=0),S.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof S.wasm.proxy!="boolean"&&(S.wasm.proxy=!1),typeof S.wasm.trace!="boolean"&&(S.wasm.trace=!1),typeof S.wasm.numThreads!="number"||!Number.isInteger(S.wasm.numThreads)||S.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)S.wasm.numThreads=1;else{let t=typeof navigator>"u"?Ne("node:os").cpus().length:navigator.hardwareConcurrency;S.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}S.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(S.wasm.wasmPaths=D.substring(0,D.lastIndexOf("/")+1))},ke=class{async init(e){Hr(),await nr(),await or(e)}async createInferenceSessionHandler(e,r){let o=new _e;return await o.loadModel(e,r),Promise.resolve(o)}}});var pr={};We(pr,{wasmBackend:()=>jr});var jr,mr=w(()=>{"use strict";lr();jr=new ke});z();z();z();var kt="1.20.0";var Ro=He;{let t=(mr(),at(pr)).wasmBackend;ne("cpu",t,10),ne("wasm",t,10)}Object.defineProperty(S.versions,"web",{value:kt,enumerable:!0});export{vr as InferenceSession,It as TRACE,$ as TRACE_FUNC_BEGIN,G as TRACE_FUNC_END,I as Tensor,Ir as TrainingSession,Ro as default,S as env,ne as registerBackend};