/* eslint-disable */
// Minified to reduce loading time (https://minify-js.com/)
/* !
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const e=Object.defineProperty,t=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,n=Object.prototype.hasOwnProperty,o=(e=>"undefined"!=typeof require?require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>("undefined"!=typeof require?require:e)[t]}):e)((function(e){if("undefined"!=typeof require)return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')})),s=(e,t)=>function(){return e&&(t=(0,e[r(e)[0]])(e=0)),t},a=(t,r)=>{for(const n in r)e(t,n,{get:r[n],enumerable:!0})},i=o=>((o,s,a,i)=>{if(s&&"object"==typeof s||"function"==typeof s)for(const u of r(s))n.call(o,u)||u===a||e(o,u,{get:()=>s[u],enumerable:!(i=t(s,u))||i.enumerable});return o})(e({},"__esModule",{value:!0}),o);let u,c,l,f,d;const p=s({"common/dist/esm/backend-impl.js"(){u=new Map,c=[],l=(e,t,r)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{const n=u.get(e);if(void 0===n)u.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){const t=c.indexOf(e);-1!==t&&c.splice(t,1);for(let t=0;t<c.length;t++)if(u.get(c[t]).priority<=r)return void c.splice(t,0,e);c.push(e)}}},f=async e=>{const t=u.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return r||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},d=async e=>{const t=e.executionProviders||[],r=t.map((e=>"string"==typeof e?e:e.name)),n=0===r.length?c:r;let o;const s=[],a=new Set;for(const e of n){const t=await f(e);"string"==typeof t?s.push({name:e,err:t}):(o||(o=t),o===t&&a.add(e))}if(!o)throw new Error(`no available backend found. ERR: ${s.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(const{name:e,err:t}of s)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);const i=t.filter((e=>a.has("string"==typeof e?e:e.name)));return[o,new Proxy(e,{get:(e,t)=>"executionProviders"===t?i:Reflect.get(e,t)})]}}}),h=s({"common/dist/esm/backend.js"(){p()}});let m;const w=s({"common/dist/esm/version.js"(){m="1.20.0"}});let y,g;const b=s({"common/dist/esm/env-impl.js"(){w(),y="warning",g={wasm:{},webgl:{},webgpu:{},versions:{common:m},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);y=e}},get logLevel(){return y}},Object.defineProperty(g,"logLevel",{enumerable:!0})}});let v;const E=s({"common/dist/esm/env.js"(){b(),v=g}});let A,T;const O=s({"common/dist/esm/tensor-conversion-impl.js"(){A=(e,t)=>{const r="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];const n=r.getContext("2d");if(null!=n){let o,s;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(o=e.dims[2],s=e.dims[3]):(o=e.dims[3],s=e.dims[2]);const a=void 0!==t?.format?t.format:"RGB",i=t?.norm;let u,c;void 0===i||void 0===i.mean?u=[255,255,255,255]:"number"==typeof i.mean?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],void 0!==i.mean[3]&&(u[3]=i.mean[3])),void 0===i||void 0===i.bias?c=[0,0,0,0]:"number"==typeof i.bias?c=[i.bias,i.bias,i.bias,i.bias]:(c=[i.bias[0],i.bias[1],i.bias[2],0],void 0!==i.bias[3]&&(c[3]=i.bias[3]));const l=s*o;let f=0,d=l,p=2*l,h=-1;"RGBA"===a?(f=0,d=l,p=2*l,h=3*l):"RGB"===a?(f=0,d=l,p=2*l):"RBG"===a&&(f=0,p=l,d=2*l);for(let t=0;t<s;t++)for(let r=0;r<o;r++){const o=(e.data[f++]-c[0])*u[0],s=(e.data[d++]-c[1])*u[1],a=(e.data[p++]-c[2])*u[2],i=-1===h?255:(e.data[h++]-c[3])*u[3];n.fillStyle="rgba("+o+","+s+","+a+","+i+")",n.fillRect(r,t,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},T=(e,t)=>{const r="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let n;if(null==r)throw new Error("Can not access image data");{let o,s,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(o=e.dims[2],s=e.dims[1],a=e.dims[3]):(o=e.dims[3],s=e.dims[2],a=e.dims[1]);const i=void 0!==t&&void 0!==t.format?t.format:"RGB",u=t?.norm;let c,l;void 0===u||void 0===u.mean?c=[255,255,255,255]:"number"==typeof u.mean?c=[u.mean,u.mean,u.mean,u.mean]:(c=[u.mean[0],u.mean[1],u.mean[2],255],void 0!==u.mean[3]&&(c[3]=u.mean[3])),void 0===u||void 0===u.bias?l=[0,0,0,0]:"number"==typeof u.bias?l=[u.bias,u.bias,u.bias,u.bias]:(l=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(l[3]=u.bias[3]));const f=s*o;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");const d=4;let p=0,h=1,m=2,w=3,y=0,g=f,b=2*f,v=-1;"RGBA"===i?(y=0,g=f,b=2*f,v=3*f):"RGB"===i?(y=0,g=f,b=2*f):"RBG"===i&&(y=0,b=f,g=2*f),n=r.createImageData(o,s);for(let t=0;t<s*o;p+=d,h+=d,m+=d,w+=d,t++)n.data[p]=(e.data[y++]-l[0])*c[0],n.data[h]=(e.data[g++]-l[1])*c[1],n.data[m]=(e.data[b++]-l[2])*c[2],n.data[w]=-1===v?255:(e.data[v++]-l[3])*c[3]}return n}}});let x,P,U,R,C;const $=s({"common/dist/esm/tensor-factory-impl.js"(){G(),x=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:r,width:n}=t,o=t.norm??{mean:255,bias:0};let s,a;s="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],a="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];const i=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",c=r*n,l="RGBA"===u?new Float32Array(4*c):new Float32Array(3*c);let f=4,d=0,p=1,h=2,m=3,w=0,y=c,g=2*c,b=-1;"RGB"===i&&(f=3,d=0,p=1,h=2,m=-1),"RGBA"===u?b=3*c:"RBG"===u?(w=0,g=c,y=2*c):"BGR"===u&&(g=0,y=c,w=2*c);for(let t=0;t<c;t++,d+=f,h+=f,p+=f,m+=f)l[w++]=(e[d]+a[0])/s[0],l[y++]=(e[p]+a[1])/s[1],l[g++]=(e[h]+a[2])/s[2],-1!==b&&-1!==m&&(l[b++]=(e[m]+a[3])/s[3]);return new N("float32",l,"RGBA"===u?[1,4,r,n]:[1,3,r,n])},P=async(e,t)=>{const r="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,n="undefined"!=typeof ImageData&&e instanceof ImageData,o="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,s="string"==typeof e;let a,i=t??{};const u=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},c=e=>e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){const r=u();r.width=e.width,r.height=e.height;const n=c(r);if(null==n)throw new Error("Can not access image data");{let r=e.height,o=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,o=t.resizedWidth),void 0!==t){if(i=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=r,i.width=o}else i.tensorFormat="RGBA",i.height=r,i.width=o;n.drawImage(e,0,0),a=n.getImageData(0,0,o,r).data}}else{if(!n){if(o){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const r=u();r.width=e.width,r.height=e.height;const n=c(r);if(null!=n){const t=e.height,r=e.width;return n.drawImage(e,0,0,r,t),a=n.getImageData(0,0,r,t).data,i.height=t,i.width=r,x(a,i)}throw new Error("Can not access image data")}if(s)return new Promise(((t,r)=>{const n=u(),o=c(n);if(!e||!o)return r();const s=new Image;s.crossOrigin="Anonymous",s.src=e,s.onload=()=>{n.width=s.width,n.height=s.height,o.drawImage(s,0,0,n.width,n.height);const e=o.getImageData(0,0,n.width,n.height);i.height=n.height,i.width=n.width,t(x(e.data,i))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,n;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,n=t.resizedWidth):(r=e.height,n=e.width),void 0!==t&&(i=t),i.format="RGBA",i.height=r,i.width=n,void 0!==t){const t=u();t.width=n,t.height=r;const o=c(t);if(null==o)throw new Error("Can not access image data");o.putImageData(e,0,0),a=o.getImageData(0,0,n,r).data}else a=e.data}}if(void 0!==a)return x(a,i);throw new Error("Input data provided is not supported - aborted tensor creation")},U=(e,t)=>{const{width:r,height:n,download:o,dispose:s}=t;return new N({location:"texture",type:"float32",texture:e,dims:[1,n,r,4],download:o,dispose:s})},R=(e,t)=>{const{dataType:r,dims:n,download:o,dispose:s}=t;return new N({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:o,dispose:s})},C=(e,t,r)=>new N({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})}});let L,I,B,S;const M=s({"common/dist/esm/tensor-impl-type-mapping.js"(){L=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),I=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),B=!1,S=()=>{if(!B){B=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,r="undefined"!=typeof Float16Array&&Float16Array.from;e&&(L.set("int64",BigInt64Array),I.set(BigInt64Array,"int64")),t&&(L.set("uint64",BigUint64Array),I.set(BigUint64Array,"uint64")),r?(L.set("float16",Float16Array),I.set(Float16Array,"float16")):L.set("float16",Uint16Array)}}}});let j,_;const k=s({"common/dist/esm/tensor-utils-impl.js"(){G(),j=e=>{let t=1;for(let r=0;r<e.length;r++){const n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},_=(e,t)=>{switch(e.location){case"cpu":return new N(e.type,e.data,t);case"cpu-pinned":return new N({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new N({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new N({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}});let N;var G=s({"common/dist/esm/tensor-impl.js"(){O(),$(),M(),k(),N=class{constructor(e,t,r){let n,o;if(S(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,n=e.type,o=e.dims,e.location){case"cpu-pinned":{const t=L.get(n);if(!t)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,a;if("string"==typeof e)if(n=e,a=r,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");s=t}else{const r=L.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);s="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t)}else{if(!(t instanceof r))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);s=t}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)n="string",s=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n="bool",s=Uint8Array.from(e)}}else{const t=I.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,s=e}if(void 0===a)a=[s.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");o=a,this.cpuData=s,this.dataLocation="cpu"}const s=j(o);if(this.cpuData&&s!==this.cpuData.length&&("uint4"!==n&&"int4"!==n||Math.ceil(s/2)!==this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=o,this.size=s}static async fromImage(e,t){return P(e,t)}static fromTexture(e,t){return U(e,t)}static fromGpuBuffer(e,t){return R(e,t)}static fromPinnedBuffer(e,t,r){return C(e,t,r)}toDataURL(e){return A(this,e)}toImageData(e){return T(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return _(this,e)}}}});let D;const F=s({"common/dist/esm/tensor.js"(){G(),D=N}});let H,z,W,V;const q=s({"common/dist/esm/trace.js"(){b(),H=(e,t)=>{(void 0===g.trace?g.wasm.trace:g.trace)&&console.timeStamp(`${e}::ORT::${t}`)},z=(e,t)=>{const r=(new Error).stack?.split(/\r\n|\r|\n/g)||[];let n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes("TRACE_FUNC")){let n=`FUNC_${e}::${r[o].trim().split(" ")[1]}`;return t&&(n+=`::${t}`),void H("CPU",n)}r[o].includes("TRACE_FUNC")&&(n=!0)}},W=e=>{(void 0===g.trace?g.wasm.trace:g.trace)&&z("BEGIN",e)},V=e=>{(void 0===g.trace?g.wasm.trace:g.trace)&&z("END",e)}}});let J;const K=s({"common/dist/esm/inference-session-impl.js"(){p(),F(),q(),J=class e{constructor(e){this.handler=e}async run(e,t,r){W();const n={};let o={};if("object"!=typeof e||null===e||e instanceof D||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof D)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{let e=!1;const a=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==a.indexOf(r)){const o=t[r];(null===o||o instanceof D)&&(e=!0,s=!1,n[r]=o)}if(e){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(s)for(const e of this.outputNames)n[e]=null;const a=await this.handler.run(e,n,o),i={};for(const e in a)if(Object.hasOwnProperty.call(a,e)){const t=a[e];i[e]=t instanceof D?t:new D(t.type,t.data,t.dims)}return V(),i}async release(){return this.handler.dispose()}static async create(t,r,n,o){let s;W();let a={};if("string"==typeof t){if(s=t,"object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,"object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const e=t;let i=0,u=t.byteLength;if("object"==typeof r&&null!==r)a=r;else if("number"==typeof r){if(i=r,!Number.isSafeInteger(i))throw new RangeError("'byteOffset' must be an integer.");if(i<0||i>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(u=t.byteLength-i,"number"==typeof n){if(u=n,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||i+u>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-i}].`);if("object"==typeof o&&null!==o)a=o;else if(void 0!==o)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==r)throw new TypeError("'options' must be an object.");s=new Uint8Array(e,i,u)}}const[i,u]=await d(a),c=await i.createInferenceSessionHandler(s,u);return V(),new e(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}});let Q;const X=s({"common/dist/esm/inference-session.js"(){K(),Q=J}}),Y=s({"common/dist/esm/tensor-conversion.js"(){}}),Z=s({"common/dist/esm/tensor-factory.js"(){}}),ee=s({"common/dist/esm/onnx-model.js"(){}}),te=s({"common/dist/esm/onnx-value.js"(){}});let re,ne;const oe=s({"common/dist/esm/training-session-impl.js"(){p(),F(),re="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",ne=class e{constructor(e,t,r){this.handler=e,this.hasOptimizerModel=t,this.hasEvalModel=r}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(t,r){const n=t.evalModel||"",o=t.optimizerModel||"",s=r||{},[a,i]=await d(s);if(a.createTrainingSessionHandler){const r=await a.createTrainingSessionHandler(t.checkpointState,t.trainModel,n,o,i);return new e(r,!!t.optimizerModel,!!t.evalModel)}throw new Error("Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.")}typeNarrowingForRunStep(e,t,r,n,o){const s={};let a={};if("object"!=typeof r||null===r||r instanceof D||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof n){if(null===n)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof D)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(0===n.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(const e of n){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===t.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);s[e]=null}if("object"==typeof o&&null!==o)a=o;else if(void 0!==o)throw new TypeError("'options' must be an object.")}else{let e=!1;const r=Object.getOwnPropertyNames(n);for(const o of t)if(-1!==r.indexOf(o)){const t=n[o];(null===t||t instanceof D)&&(e=!0,i=!1,s[o]=t)}if(e){if("object"==typeof o&&null!==o)a=o;else if(void 0!==o)throw new TypeError("'options' must be an object.")}else a=n}}else if(void 0!==n)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of e)if(void 0===r[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of t)s[e]=null;return[s,a]}convertHandlerReturnTypeToMapOfTensors(e){const t={};for(const r in e)if(Object.hasOwnProperty.call(e,r)){const n=e[r];t[r]=n instanceof D?n:new D(n.type,n.data,n.dims)}return t}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,t,r){const[n,o]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,t,r),s=await this.handler.runTrainStep(e,n,o);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(!this.hasOptimizerModel)throw new Error("This TrainingSession has no OptimizerModel loaded.");await this.handler.runOptimizerStep(e||{})}async runEvalStep(e,t,r){if(this.hasEvalModel){const[n,o]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,t,r),s=await this.handler.runEvalStep(e,n,o);return this.convertHandlerReturnTypeToMapOfTensors(s)}throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,t=!0){const r=await this.getParametersSize(t);if(e.length!==4*r)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,t)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}}});let se;const ae=s({"common/dist/esm/training-session.js"(){oe(),se=ne}}),ie={};a(ie,{InferenceSession:()=>Q,TRACE:()=>H,TRACE_FUNC_BEGIN:()=>W,TRACE_FUNC_END:()=>V,Tensor:()=>D,TrainingSession:()=>se,env:()=>v,registerBackend:()=>l});const ue=s({"common/dist/esm/index.js"(){h(),E(),X(),F(),Y(),Z(),q(),ee(),te(),ae()}});let ce;const le=s({"web/lib/wasm/wasm-utils-env.ts"(){ce=!1}}),fe={};let de,pe,he;a(fe,{default:()=>he});const me=s({"web/lib/wasm/proxy-worker/main.ts"(){yt(),je(),Ue(),de="ort-wasm-proxy-worker",pe=globalThis.self?.name===de,pe&&(self.onmessage=e=>{const{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Se(r.wasm).then((()=>{at(r).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}))}),(e=>{postMessage({type:t,err:e})}));break;case"init-ep":{const{epName:e,env:n}=r;it(n,e).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}));break}case"copy-from":{const{buffer:e}=r,n=lt(e);postMessage({type:t,out:n});break}case"create":{const{model:e,options:n}=r;ft(e,n).then((e=>{postMessage({type:t,out:e})}),(e=>{postMessage({type:t,err:e})}));break}case"release":dt(r),postMessage({type:t});break;case"run":{const{sessionId:e,inputIndices:n,inputs:o,outputIndices:s,options:a}=r;ht(e,n,o,s,new Array(s.length).fill(null),a).then((e=>{e.some((e=>"cpu"!==e[3]))?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},wt([...o,...e]))}),(e=>{postMessage({type:t,err:e})}));break}case"end-profiling":mt(r),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),he=pe?null:e=>new Worker(e??we,{type:"module",name:de})}});let we,ye,ge,be,ve,Ee,Ae,Te,Oe,xe,Pe;var Ue=s({"web/lib/wasm/wasm-utils-import.ts"(){le(),we=ce?void 0:import.meta.url??("undefined"!=typeof document?document.currentScript?.src:"undefined"!=typeof self?self.location?.href:void 0),ye=ce||"undefined"==typeof location?void 0:location.origin,ge=(e,t)=>{try{const r=t??we;return(r?new URL(e,r):new URL(e)).origin===ye}catch{return!1}},be=(e,t)=>{const r=t??we;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},ve=(e,t)=>`${t??"./"}${e}`,Ee=async e=>{const t=await fetch(e,{credentials:"same-origin"}),r=await t.blob();return URL.createObjectURL(r)},Ae=async e=>(await import(e)).default,Te=(me(),i(fe)).default,Oe=async()=>{if(!we)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(ge(we))return[void 0,Te()];const e=await Ee(we);return[e,Te(e)]},xe=void 0,Pe=async(e,t,r)=>{{const n="ort-wasm-simd-threaded.mjs",o=e??be(n,t),s=!ce&&r&&o&&!ge(o,t),a=s?await Ee(o):o??ve(n,t);return[s?a:void 0,await Ae(a)]}}}});let Re,Ce,$e,Le,Ie,Be,Se,Me;var je=s({"web/lib/wasm/wasm-factory.ts"(){Ue(),Ce=!1,$e=!1,Le=!1,Ie=()=>{if("undefined"==typeof SharedArrayBuffer)return!1;try{return"undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}},Be=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}},Se=async e=>{if(Ce)return Promise.resolve();if($e)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Le)throw new Error("previous call to 'initializeWebAssembly()' failed.");$e=!0;const t=e.initTimeout;let r=e.numThreads;if(!Be())throw new Error("WebAssembly SIMD is not supported in the current environment.");const n=Ie();r>1&&!n&&("undefined"==typeof self||self.crossOriginIsolated||console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);const o=e.wasmPaths,s="string"==typeof o?o:void 0,a=o?.mjs,i=a?.href??a,u=o?.wasm,c=u?.href??u,l=e.wasmBinary,[f,d]=await Pe(i,s,r>1);let p=!1;const h=[];if(t>0&&h.push(new Promise((e=>{setTimeout((()=>{p=!0,e()}),t)}))),h.push(new Promise(((e,t)=>{const n={numThreads:r};l?n.wasmBinary=l:(c||s)&&(n.locateFile=(e,t)=>c??(s??t)+e),d(n).then((t=>{$e=!1,Ce=!0,Re=t,e(),f&&URL.revokeObjectURL(f)}),(e=>{$e=!1,Le=!0,t(e)}))}))),await Promise.race(h),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Me=()=>{if(Ce&&Re)return Re;throw new Error("WebAssembly is not initialized yet.")}}});let _e,ke,Ne;const Ge=s({"web/lib/wasm/wasm-utils.ts"(){je(),_e=(e,t)=>{const r=Me(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},ke=(e,t,r,n)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const s=t?t+e:e;if("object"==typeof o)ke(o,s+".",r,n);else if("string"==typeof o||"number"==typeof o)n(s,o.toString());else{if("boolean"!=typeof o)throw new Error("Can't handle extra config type: "+typeof o);n(s,o?"1":"0")}}))},Ne=e=>{const t=Me(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],o=t.HEAPU32[r/4+1],s=o?t.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(r)}}}});let De;const Fe=s({"web/lib/wasm/run-options.ts"(){je(),Ge(),De=e=>{const t=Me();let r=0;const n=[],o=e||{};try{if(void 0===e?.logSeverityLevel)o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(o.terminate=!1);let s=0;return void 0!==e?.tag&&(s=_e(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,s),0===r&&Ne("Can't create run options."),void 0!==e?.extra&&ke(e.extra,"",new WeakSet,((e,o)=>{const s=_e(e,n),a=_e(o,n);0!==t._OrtAddRunConfigEntry(r,s,a)&&Ne(`Can't set a run config entry: ${e} - ${o}.`)})),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),n.forEach((e=>t._free(e))),e}}}});let He,ze,We,Ve,qe;const Je=s({"web/lib/wasm/session-options.ts"(){je(),Ge(),He=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},ze=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},We=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},Ve=(e,t,r)=>{for(const n of t){let t="string"==typeof n?n:n.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof n){const t=n,o=t?.deviceType;if(o){const t=_e("deviceType",r),n=_e(o,r);0!==Me()._OrtAddSessionConfigEntry(e,t,n)&&Ne(`Can't set a session config entry: 'deviceType' - ${o}.`)}}break;case"webgpu":if(t="JS","string"!=typeof n){const t=n;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);const n=_e("preferredLayout",r),o=_e(t.preferredLayout,r);0!==Me()._OrtAddSessionConfigEntry(e,n,o)&&Ne(`Can't set a session config entry: 'preferredLayout' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const o=_e(t,r);0!==Me()._OrtAppendExecutionProvider(e,o)&&Ne(`Can't append execution provider: ${t}.`)}},qe=e=>{const t=Me();let r=0;const n=[],o=e||{};We(o);try{const e=He(o.graphOptimizationLevel??"all"),s=ze(o.executionMode??"sequential"),a="string"==typeof o.logId?_e(o.logId,n):0,i=o.logSeverityLevel??2;if(!Number.isInteger(i)||i<0||i>4)throw new Error(`log serverity level is not valid: ${i}`);const u=o.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);const c="string"==typeof o.optimizedModelFilePath?_e(o.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(e,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,a,i,u,c),0===r&&Ne("Can't create session options."),o.executionProviders&&Ve(r,o.executionProviders,n),void 0!==o.enableGraphCapture){if("boolean"!=typeof o.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);const e=_e("enableGraphCapture",n),s=_e(o.enableGraphCapture.toString(),n);0!==t._OrtAddSessionConfigEntry(r,e,s)&&Ne(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(const[e,s]of Object.entries(o.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof s||!Number.isInteger(s)||s<0)throw new Error(`free dimension override value must be a non-negative integer: ${s}`);const o=_e(e,n);0!==t._OrtAddFreeDimensionOverride(r,o,s)&&Ne(`Can't set a free dimension override: ${e} - ${s}.`)}return void 0!==o.extra&&ke(o.extra,"",new WeakSet,((e,o)=>{const s=_e(e,n),a=_e(o,n);0!==t._OrtAddSessionConfigEntry(r,s,a)&&Ne(`Can't set a session config entry: ${e} - ${o}.`)})),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseSessionOptions(r),n.forEach((e=>t._free(e))),e}}}});let Ke,Qe,Xe,Ye,Ze,et,tt;const rt=s({"web/lib/wasm/wasm-common.ts"(){Ke=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Qe=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Xe=(e,t)=>{const r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n="number"==typeof t?t:t.reduce(((e,t)=>e*t),1);return r>0?Math.ceil(n*r):void 0},Ye=e=>{switch(e){case"float16":return"undefined"!=typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ze=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},et=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,tt=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}}});let nt;const ot=s({"web/lib/wasm/wasm-utils-load-file.ts"(){le(),nt=async e=>{if("string"!=typeof e)return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e);if(!ce){const t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);const r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);const r=t.body.getReader();let o;try{o=new ArrayBuffer(n)}catch(e){if(!(e instanceof RangeError))throw e;{const e=Math.ceil(n/65536);o=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let s=0;for(;;){const{done:e,value:t}=await r.read();if(e)break;const n=t.byteLength;new Uint8Array(o,s,n).set(t),s+=n}return new Uint8Array(o,0,n)}}try{const{readFile:t}=o("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if("ERR_FS_FILE_TOO_LARGE"===t.code){const{createReadStream:t}=o("node:fs"),r=t(e),n=[];for await(const e of r)n.push(e);return new Uint8Array(Buffer.concat(n))}throw t}}}});let st,at,it,ut,ct,lt,ft,dt,pt,ht,mt,wt;var yt=s({"web/lib/wasm/wasm-core-impl.ts"(){Fe(),Je(),rt(),je(),Ge(),ot(),st=(e,t)=>{0!==Me()._OrtInit(e,t)&&Ne("Can't initialize onnxruntime.")},at=async e=>{st(e.wasm.numThreads,Ze(e.logLevel))},it=async(e,t)=>{0},ut=new Map,ct=e=>{const t=Me(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&Ne("Can't get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}},lt=e=>{const t=Me(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},ft=async(e,t)=>{let r,n;const o=Me();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=lt(e);let s=0,a=0,i=0,u=[];const c=[],l=[];try{if([a,u]=qe(t),t?.externalData&&o.mountExternalData){const e=[];for(const r of t.externalData){const t="string"==typeof r?r:r.path;e.push(nt("string"==typeof r?r:r.data).then((e=>{o.mountExternalData(t,e)})))}await Promise.all(e)}for(const e of t?.executionProviders??[]){if("webnn"===("string"==typeof e?e:e.name)){if(o.currentContext)throw new Error("WebNN execution provider is already set.");if("string"!=typeof e){const t=e,r=t?.context,n=t?.gpuDevice,s=t?.deviceType,a=t?.numThreads,i=t?.powerPreference;o.currentContext=r||(n?await navigator.ml.createContext(n):await navigator.ml.createContext({deviceType:s,numThreads:a,powerPreference:i}))}else o.currentContext=await navigator.ml.createContext();break}}s=await o._OrtCreateSession(r,n,a),0===s&&Ne("Can't create a session."),o.currentContext&&(o.currentContext=void 0);const[e,i]=ct(s),f=!!t?.enableGraphCapture,d=[],p=[];for(let t=0;t<e;t++){const e=o._OrtGetInputName(s,t);0===e&&Ne("Can't get an input name."),c.push(e),d.push(o.UTF8ToString(e))}for(let e=0;e<i;e++){const t=o._OrtGetOutputName(s,e);0===t&&Ne("Can't get an output name."),l.push(t);const r=o.UTF8ToString(t);p.push(r)}let h=null;return ut.set(s,[s,c,l,h,f,!1]),[s,d,p]}catch(e){throw c.forEach((e=>o._OrtFree(e))),l.forEach((e=>o._OrtFree(e))),0!==i&&o._OrtReleaseBinding(i),0!==s&&o._OrtReleaseSession(s),e}finally{o._free(r),0!==a&&o._OrtReleaseSessionOptions(a),u.forEach((e=>o._free(e))),o.unmountExternalData?.()}},dt=e=>{const t=Me(),r=ut.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,o,s,a,i]=r;a&&(i&&t._OrtClearBoundOutputs(a.handle),t._OrtReleaseBinding(a.handle)),t.jsepOnReleaseSession?.(e),o.forEach((e=>t._OrtFree(e))),s.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),ut.delete(e)},pt=(e,t,r,n,o,s=!1)=>{if(!e)return void t.push(0);const a=Me(),i=e[0],u=e[1],c=e[3];let l,f;if("string"===i&&"gpu-buffer"===c)throw new Error("String tensor is not supported on GPU.");if(s&&"gpu-buffer"!==c)throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if("gpu-buffer"===c){const t=e[2].gpuBuffer;f=Xe(Ke(i),u);const r=a.jsepRegisterBuffer;if(!r)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');l=r(n,o,t,f)}else{const t=e[2];if(Array.isArray(t)){f=4*t.length,l=a._malloc(f),r.push(l);let e=l/4;for(let n=0;n<t.length;n++){if("string"!=typeof t[n])throw new TypeError(`tensor data at index ${n} is not a string`);a.HEAPU32[e++]=_e(t[n],r)}}else f=t.byteLength,l=a._malloc(f),r.push(l),a.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,f),l)}const d=a.stackSave(),p=a.stackAlloc(4*u.length);try{let e=p/4;u.forEach((t=>a.HEAP32[e++]=t));const r=a._OrtCreateTensor(Ke(i),l,f,p,u.length,tt(c));0===r&&Ne(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(r)}finally{a.stackRestore(d)}},ht=async(e,t,r,n,o,s)=>{const a=Me(),i=ut.get(e);if(!i)throw new Error(`cannot run inference. invalid session id: ${e}`);const u=i[0],c=i[1],l=i[2],f=i[3],d=i[4],p=(i[5],t.length),h=n.length;let m=0,w=[];const y=[],g=[],b=[],v=a.stackSave(),E=a.stackAlloc(4*p),A=a.stackAlloc(4*p),T=a.stackAlloc(4*h),O=a.stackAlloc(4*h);try{[m,w]=De(s);for(let n=0;n<p;n++)pt(r[n],y,b,e,t[n],d);for(let t=0;t<h;t++)pt(o[t],g,b,e,p+n[t],d);let i,v=E/4,x=A/4,P=T/4,U=O/4;for(let e=0;e<p;e++)a.HEAPU32[v++]=y[e],a.HEAPU32[x++]=c[t[e]];for(let e=0;e<h;e++)a.HEAPU32[P++]=g[e],a.HEAPU32[U++]=l[n[e]];0,a.jsepOnRunStart?.(u),i=await a._OrtRun(u,A,E,p,O,h,T,m),0!==i&&Ne("failed to call OrtRun().");const R=[];for(let e=0;e<h;e++){const t=a.HEAPU32[T/4+e];if(t===g[e]){R.push(o[e]);continue}const r=a.stackSave(),s=a.stackAlloc(16);let i,u=!1,c=0;try{0!==a._OrtGetTensorData(t,s,s+4,s+8,s+12)&&Ne(`Can't access output tensor data on index ${e}.`);let r=s/4;const o=a.HEAPU32[r++];c=a.HEAPU32[r++];const l=a.HEAPU32[r++],d=a.HEAPU32[r++],p=[];for(let e=0;e<d;e++)p.push(a.HEAPU32[l/4+e]);a._OrtFree(l);const h=p.reduce(((e,t)=>e*t),1);i=Qe(o);const m=f?.outputPreferredLocations[n[e]];if("string"===i){if("gpu-buffer"===m)throw new Error("String tensor is not supported on GPU.");const e=[];let t=c/4;for(let r=0;r<h;r++){const n=a.HEAPU32[t++],o=r===h-1?void 0:a.HEAPU32[t]-n;e.push(a.UTF8ToString(n,o))}R.push([i,p,e,"cpu"])}else if("gpu-buffer"===m&&h>0){const e=a.jsepGetBuffer;if(!e)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');const r=e(c),n=Xe(o,h);if(void 0===n||!et(i))throw new Error(`Unsupported data type: ${i}`);u=!0,R.push([i,p,{gpuBuffer:r,download:a.jsepCreateDownloader(r,n,i),dispose:()=>{a._OrtReleaseTensor(t)}},"gpu-buffer"])}else{const e=new(Ye(i))(h);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(a.HEAPU8.subarray(c,c+e.byteLength)),R.push([i,p,e,"cpu"])}}finally{a.stackRestore(r),"string"===i&&c&&a._free(c),u||a._OrtReleaseTensor(t)}}return f&&!d&&(a._OrtClearBoundOutputs(f.handle),ut.set(e,[u,c,l,f,d,!1])),R}finally{a.stackRestore(v),y.forEach((e=>a._OrtReleaseTensor(e))),g.forEach((e=>a._OrtReleaseTensor(e))),b.forEach((e=>a._free(e))),0!==m&&a._OrtReleaseRunOptions(m),w.forEach((e=>a._free(e)))}},mt=e=>{const t=Me(),r=ut.get(e);if(!r)throw new Error("invalid session id");const n=r[0],o=t._OrtEndProfiling(n);0===o&&Ne("Can't get an profile file name."),t._OrtFree(o)},wt=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}}});let gt,bt,vt,Et,At,Tt,Ot,xt,Pt,Ut,Rt,Ct,$t,Lt,It,Bt,St,Mt;const jt=s({"web/lib/wasm/proxy-wrapper.ts"(){ue(),yt(),je(),Ue(),gt=()=>!!v.wasm.proxy&&"undefined"!=typeof document,vt=!1,Et=!1,At=!1,xt=new Map,Pt=(e,t)=>{const r=xt.get(e);r?r.push(t):xt.set(e,[t])},Ut=()=>{if(vt||!Et||At||!bt)throw new Error("worker not ready")},Rt=e=>{switch(e.data.type){case"init-wasm":vt=!1,e.data.err?(At=!0,Ot[1](e.data.err)):(Et=!0,Ot[0]()),Tt&&(URL.revokeObjectURL(Tt),Tt=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{const t=xt.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},Ct=async()=>{if(!Et){if(vt)throw new Error("multiple calls to 'initWasm()' detected.");if(At)throw new Error("previous call to 'initWasm()' failed.");if(vt=!0,gt())return new Promise(((e,t)=>{bt?.terminate(),Oe().then((([r,n])=>{try{bt=n,bt.onerror=e=>t(e),bt.onmessage=Rt,Ot=[e,t];const o={type:"init-wasm",in:v};bt.postMessage(o),Tt=r}catch(e){t(e)}}),t)}));try{await Se(v.wasm),await at(v),Et=!0}catch(e){throw At=!0,e}finally{vt=!1}}},$t=async e=>{if(gt())return Ut(),new Promise(((t,r)=>{Pt("init-ep",[t,r]);const n={type:"init-ep",in:{epName:e,env:v}};bt.postMessage(n)}));await it(v,e)},Lt=async e=>gt()?(Ut(),new Promise(((t,r)=>{Pt("copy-from",[t,r]);const n={type:"copy-from",in:{buffer:e}};bt.postMessage(n,[e.buffer])}))):lt(e),It=async(e,t)=>{if(gt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Ut(),new Promise(((r,n)=>{Pt("create",[r,n]);const o={type:"create",in:{model:e,options:{...t}}},s=[];e instanceof Uint8Array&&s.push(e.buffer),bt.postMessage(o,s)}))}return ft(e,t)},Bt=async e=>{if(gt())return Ut(),new Promise(((t,r)=>{Pt("release",[t,r]);const n={type:"release",in:e};bt.postMessage(n)}));dt(e)},St=async(e,t,r,n,o,s)=>{if(gt()){if(r.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(o.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return Ut(),new Promise(((o,a)=>{Pt("run",[o,a]);const i=r,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:i,outputIndices:n,options:s}};bt.postMessage(u,wt(i))}))}return ht(e,t,r,n,o,s)},Mt=async e=>{if(gt())return Ut(),new Promise(((t,r)=>{Pt("end-profiling",[t,r]);const n={type:"end-profiling",in:e};bt.postMessage(n)}));mt(e)}}});let _t,kt,Nt;const Gt=s({"web/lib/wasm/session-handler-inference.ts"(){ue(),jt(),rt(),le(),ot(),_t=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},kt=e=>{switch(e[3]){case"cpu":return new D(e[0],e[2],e[1]);case"gpu-buffer":{const t=e[0];if(!et(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);const{gpuBuffer:r,download:n,dispose:o}=e[2];return D.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},Nt=class{async fetchModelAndCopyToWasmMemory(e){return Lt(await nt(e))}async loadModel(e,t){let r;W(),r="string"==typeof e?ce?await nt(e):await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await It(r,t),V()}async dispose(){return Bt(this.sessionId)}async run(e,t,r){W();const n=[],o=[];Object.entries(e).forEach((e=>{const t=e[0],r=e[1],s=this.inputNames.indexOf(t);if(-1===s)throw new Error(`invalid input '${t}'`);n.push(r),o.push(s)}));const s=[],a=[];Object.entries(t).forEach((e=>{const t=e[0],r=e[1],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);s.push(r),a.push(n)}));const i=n.map(((e,t)=>_t(e,(()=>`input "${this.inputNames[o[t]]}"`)))),u=s.map(((e,t)=>e?_t(e,(()=>`output "${this.outputNames[a[t]]}"`)):null)),c=await St(this.sessionId,o,i,a,u,r),l={};for(let e=0;e<c.length;e++)l[this.outputNames[a[e]]]=s[e]??kt(c[e]);return V(),l}startProfiling(){}endProfiling(){Mt(this.sessionId)}}}});let Dt,Ft;const Ht=s({"web/lib/backend-wasm.ts"(){ue(),jt(),Gt(),Ue(),Dt=()=>{if(("number"!=typeof v.wasm.initTimeout||v.wasm.initTimeout<0)&&(v.wasm.initTimeout=0),!1===v.wasm.simd&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),"boolean"!=typeof v.wasm.proxy&&(v.wasm.proxy=!1),"boolean"!=typeof v.wasm.trace&&(v.wasm.trace=!1),"number"!=typeof v.wasm.numThreads||!Number.isInteger(v.wasm.numThreads)||v.wasm.numThreads<=0)if("undefined"==typeof self||self.crossOriginIsolated){const e="undefined"==typeof navigator?o("node:os").cpus().length:navigator.hardwareConcurrency;v.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}else v.wasm.numThreads=1;void 0===v.wasm.wasmPaths&&we&&0!==we.indexOf("blob:")&&(v.wasm.wasmPaths=we.substring(0,we.lastIndexOf("/")+1))},Ft=class{async init(e){Dt(),await Ct(),await $t(e)}async createInferenceSessionHandler(e,t){const r=new Nt;return await r.loadModel(e,t),Promise.resolve(r)}}}}),zt={};let Wt;a(zt,{wasmBackend:()=>Wt});const Vt=s({"web/lib/backend-wasm-inference.ts"(){Ht(),Wt=new Ft}});ue(),ue(),ue();const qt=ie;{const e=(Vt(),i(zt)).wasmBackend;0,l("cpu",e,10),l("wasm",e,10)}Object.defineProperty(v.versions,"web",{value:"1.20.0",enumerable:!0});export{Q as InferenceSession,H as TRACE,W as TRACE_FUNC_BEGIN,V as TRACE_FUNC_END,D as Tensor,se as TrainingSession,qt as default,v as env,l as registerBackend};